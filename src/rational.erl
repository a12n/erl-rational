%%%-------------------------------------------------------------------
%%% @author Anton Yabchinskiy <arn@bestmx.ru>
%%% @doc
%%% @end
%%% For copyright notice see LICENSE.
%%%-------------------------------------------------------------------
-module(rational).

%% Types
-export_type([rational/0]).

%% API
-export([new/1, new/2]).

%% API
-export([eq/2, ge/2, gt/2, ne/2, le/2, lt/2]).

%% API
-export([diff/2, inv/1, neg/1, prod/2, quot/2, sum/2]).

%%%===================================================================
%%% Types
%%%===================================================================

-type rational() :: {rational, integer(), integer()}.

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec new(integer()) -> rational().

new(Num) when is_integer(Num) ->
    {rational, Num, 1};

new(_Num) ->
    error(badarg).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec new(integer(), integer()) -> rational().

new(Num, Denom)
  when is_integer(Num),
       is_integer(Denom) ->
    reduce(normalize({rational, Num, Denom}));

new(_Num, _Denom) ->
    error(badarg).

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec eq(rational(), rational()) -> boolean().

eq({rational, A, B}, {rational, C, D})
  when is_integer(A), is_integer(B),
       is_integer(C), is_integer(D) ->
    (A * D) =:= (B * C);

eq(_Q1, _Q2) ->
    error(badarith).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec ge(rational(), rational()) -> boolean().

ge(Q1, Q2) ->
    not(lt(Q1, Q2)).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec gt(rational(), rational()) -> boolean().

gt(Q1, Q2) ->
    lt(Q2, Q1).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec ne(rational(), rational()) -> boolean().

ne(Q1, Q2) ->
    not(eq(Q1, Q2)).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec le(rational(), rational()) -> boolean().

le(Q1, Q2) ->
    not(lt(Q2, Q1)).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec lt(rational(), rational()) -> boolean().

lt(Q1 = {rational, _A, B}, Q2) when B < 0 ->
    lt(normalize(Q1), Q2);

lt(Q1, Q2 = {rational, _C, D}) when D < 0 ->
    lt(Q1, normalize(Q2));

lt({rational, A, B}, {rational, C, D})
  when is_integer(A), is_integer(B),
       is_integer(C), is_integer(D) ->
    (A * D) < (B * C);

lt(_Q1, _Q2) ->
    error(badarith).

%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec diff(rational(), rational()) -> rational().

diff(Q1, Q2) ->
    sum(Q1, neg(Q2)).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec inv(rational()) -> rational().

inv({rational, A, B}) ->
    {rational, B, A}.

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec neg(rational()) -> rational().

neg({rational, A, B}) ->
    {rational, -A, B}.

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec prod(rational(), rational()) -> rational().

prod({rational, A, B}, {rational, C, D})
  when is_integer(A), is_integer(B),
       is_integer(C), is_integer(D) ->
    reduce(normalize({rational, (A * C), (B * D)}));

prod(_Q1, _Q2) ->
    error(badarith).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec quot(rational(), rational()) -> rational().

quot(Q1, Q2) ->
    prod(Q1, inv(Q2)).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec sum(rational(), rational()) -> rational().

sum({rational, A, B}, {rational, C, D})
  when is_integer(A), is_integer(B),
       is_integer(C), is_integer(D) ->
    reduce(normalize({rational, (A * D) + (C * B), (B * D)}));

sum(_Q1, _Q2) ->
    error(badarith).

%%%===================================================================
%%% Internal functions
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec gcd(non_neg_integer(), non_neg_integer()) -> non_neg_integer().

gcd(A, 0) -> A;

gcd(A, B) -> gcd(B, A rem B).

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec normalize(rational()) -> rational().

normalize({rational, A, B}) when B < 0 ->
    {rational, -A, -B};

normalize(Q) ->
    Q.

%%--------------------------------------------------------------------
%% @doc
%% @end
%%--------------------------------------------------------------------
-spec reduce(rational()) -> rational().

reduce({rational, A, B}) ->
    K = gcd(A, B),
    {rational, A div K, B div K}.
